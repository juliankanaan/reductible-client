{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _parseInt2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/parse-int\"));\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/get-iterator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/esm/asyncToGenerator\"));\n\n//require('dotenv').config();\nvar fetch = require('isomorphic-fetch'); // maybe get thus from the ``\n\n\nvar restApiPath = 'https://localhost:4000/post/push';\n\nfunction callAsync(_x, _x2, _x3, _x4) {\n  return _callAsync.apply(this, arguments);\n}\n\nfunction _callAsync() {\n  _callAsync = (0, _asyncToGenerator2.default)(\n  /*#__PURE__*/\n  _regenerator.default.mark(function _callee(url, descStart, descEnd, priceColumn) {\n    var response, data;\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(url);\n\n          case 2:\n            response = _context.sent;\n            _context.next = 5;\n            return response.text();\n\n          case 5:\n            data = _context.sent;\n            return _context.abrupt(\"return\", transformer(data, descStart, descEnd, priceColumn));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _callAsync.apply(this, arguments);\n}\n\nfunction transformer(data, descStart, descEnd, priceColumn) {\n  var readyVals = []; // separate into lines\n\n  var lines = returnLines(data); // JSON populate\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = (0, _getIterator2.default)(lines), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var line = _step.value;\n      var jsonReady = groupDataReturnRecord(line, descStart, descEnd, priceColumn); //readyVals.push(jsonReady);\n      //console.log(jsonReady);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return readyVals;\n}\n\nfunction returnLines(data) {\n  // works: 2:40pm\n  var lines = [];\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = (0, _getIterator2.default)(data.split('\\n')), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var line = _step2.value;\n      lines.push(line.replace(/\\s+/g, ' ')); // trimmed extra spaces\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  lines.pop(); // there's always an empty element created at end, remove it\n\n  return lines;\n}\n\nfunction groupDataReturnRecord(line, descStart, descEnd, priceColumn) {\n  // create arr\n  var arr = line.split(\" \");\n  arr.pop();\n  console.log(arr);\n  var record = {\n    hospital: '',\n    procedureName: '',\n    procedureCost: ''\n  };\n  var cost = arr[arr.length + (0, _parseInt2.default)(priceColumn)]; // probably -2 position\n  // convert relative negative pos for descEnd to positive for this array\n\n  var positiveEnd = arr.indexOf(arr[arr.length + (0, _parseInt2.default)(descEnd)]); // remap\n\n  var description = arr.map(function (word, pos) {\n    if (pos >= (0, _parseInt2.default)(descStart) && pos <= positiveEnd) {\n      return word;\n    }\n  });\n  record['procedureName'] = description.join(\" \");\n  record['procedureCost'] = cost; //console.log(cost);\n\n  return record;\n}\n\nfunction postToApi(_x5) {\n  return _postToApi.apply(this, arguments);\n}\n\nfunction _postToApi() {\n  _postToApi = (0, _asyncToGenerator2.default)(\n  /*#__PURE__*/\n  _regenerator.default.mark(function _callee2(data) {\n    var post, request;\n    return _regenerator.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return fetch(restApiPath, {\n              method: 'POST',\n              body: (0, _stringify.default)({\n                hospital: data.hospital,\n                procedureName: data.procedureName,\n                procedureCost: data.procedureCost\n              }),\n              headers: {\n                'Content-Type': 'application/json'\n              }\n            });\n\n          case 2:\n            post = _context2.sent;\n            _context2.next = 5;\n            return response.json();\n\n          case 5:\n            request = _context2.sent;\n            console.log(request);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _postToApi.apply(this, arguments);\n}\n\nmodule.exports.callAsync = callAsync;","map":{"version":3,"sources":["/Users/juliankanaan/Documents/GitHub/clientReactInterfact/helpers/helper.js"],"names":["fetch","require","restApiPath","callAsync","url","descStart","descEnd","priceColumn","response","text","data","transformer","readyVals","lines","returnLines","line","jsonReady","groupDataReturnRecord","split","push","replace","pop","arr","console","log","record","hospital","procedureName","procedureCost","cost","length","positiveEnd","indexOf","description","map","word","pos","join","postToApi","method","body","headers","post","json","request","module","exports"],"mappings":"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","sourcesContent":["//require('dotenv').config();\nconst fetch = require('isomorphic-fetch');\n// maybe get thus from the ``\nconst restApiPath = 'https://localhost:4000/post/push';\n\n\nasync function callAsync(url, descStart, descEnd, priceColumn) {\n  const response = await fetch(url);\n  const data = await response.text();\n  return transformer(data, descStart, descEnd, priceColumn);\n}\n\nfunction transformer(data, descStart, descEnd, priceColumn) {\n  var readyVals = [];\n  // separate into lines\n  const lines = returnLines(data);\n  // JSON populate\n  for (var line of lines) {\n    var jsonReady = groupDataReturnRecord(line, descStart, descEnd, priceColumn);\n    //readyVals.push(jsonReady);\n    //console.log(jsonReady);\n  }\n  return readyVals;\n}\n\nfunction returnLines(data) { // works: 2:40pm\n  var lines = [];\n  for (var line of data.split('\\n')) {\n    lines.push(line.replace(/\\s+/g, ' ')); // trimmed extra spaces\n\n  }\n  lines.pop(); // there's always an empty element created at end, remove it\n  return lines;\n}\n\nfunction groupDataReturnRecord(line, descStart, descEnd, priceColumn) {\n  // create arr\n  var arr = line.split(\" \");\n  arr.pop(); \n  console.log(arr);\n  const record = {\n    hospital: '',\n    procedureName: '',\n    procedureCost: ''\n  }\n\n  const cost = arr[arr.length + parseInt(priceColumn)]; // probably -2 position\n  // convert relative negative pos for descEnd to positive for this array\n  const positiveEnd = arr.indexOf(arr[arr.length + parseInt(descEnd)]);\n  // remap\n  var description = arr.map((word, pos) => {\n    if (pos >= parseInt(descStart) && pos <= positiveEnd) {\n      return word;\n    }\n  });\n\n  record['procedureName'] = description.join(\" \");\n  record['procedureCost'] = cost;\n  //console.log(cost);\n  return record;\n}\nasync function postToApi(data) {\n  // push a single data point to DB\n  // NOTE: maybe use bulk insert?\n  const post = await fetch(restApiPath, {\n    method: 'POST',\n    body: JSON.stringify({\n      hospital: data.hospital,\n      procedureName: data.procedureName,\n      procedureCost: data.procedureCost\n    }),\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  const request = await response.json();\n  console.log(request);\n}\nmodule.exports.callAsync = callAsync;\n"]},"metadata":{},"sourceType":"script"}