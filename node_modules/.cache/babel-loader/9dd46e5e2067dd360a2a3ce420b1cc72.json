{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/get-iterator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/esm/asyncToGenerator\"));\n\n//require('dotenv').config();\nvar fetch = require('isomorphic-fetch'); // maybe get thus from the ``\n\n\nvar restApiPath = 'https://localhost:4000/post/push';\n\nfunction callAsync(_x, _x2) {\n  return _callAsync.apply(this, arguments);\n}\n\nfunction _callAsync() {\n  _callAsync = (0, _asyncToGenerator2.default)(\n  /*#__PURE__*/\n  _regenerator.default.mark(function _callee(url, schema) {\n    var response, data;\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(url);\n\n          case 2:\n            response = _context.sent;\n            _context.next = 5;\n            return response.json();\n\n          case 5:\n            data = _context.sent;\n            return _context.abrupt(\"return\", formatter(data, schema));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _callAsync.apply(this, arguments);\n}\n\nfunction formatter(data, schema) {\n  // separate into lines\n\n  /*\n  var lines = returnLines(data);\n   for (line of lines) {\n    //\n    getPriceProcedurePairs(line, schema)\n  }\n  */\n  return data;\n}\n\nfunction returnLines(data) {\n  // works: 2:40pm\n  var lines = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = (0, _getIterator2.default)(data.split('\\n')), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      line = _step.value;\n      lines.push(line.replace(/\\s+/g, ' ')); // trimmed extra spaces\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return lines;\n}\n\nfunction groupDataReturnArrs(line) {\n  // create arr\n  var arr = line.split(\" \");\n  var chars = [];\n  var nums = [];\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = (0, _getIterator2.default)(arr), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      word = _step2.value;\n\n      //console.log(word);\n      if (!isNaN(word)) {\n        console.log('number');\n      } else {\n        console.log('not num');\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n\nfunction getPriceProcedurePairs(line, schema) {\n  // loop concurrently over each array. ALSO: try to catch errors (index out of range, just ignore the bad rows )\n  // then join the descriptions together\n  // then push into json pairs\n  var jsonData = (0, _stringify.default)({\n    hospital: '',\n    procedureName: '',\n    procedureCost: ''\n  }); //console.log(jsonData);\n\n  return postToApi(jsonData);\n}\n\nfunction postToApi(_x3) {\n  return _postToApi.apply(this, arguments);\n}\n\nfunction _postToApi() {\n  _postToApi = (0, _asyncToGenerator2.default)(\n  /*#__PURE__*/\n  _regenerator.default.mark(function _callee2(data) {\n    var post, request;\n    return _regenerator.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return fetch(restApiPath, {\n              method: 'POST',\n              body: (0, _stringify.default)({\n                hospital: data.hospital,\n                procedureName: data.procedureName,\n                procedureCost: data.procedureCost\n              }),\n              headers: {\n                'Content-Type': 'application/json'\n              }\n            });\n\n          case 2:\n            post = _context2.sent;\n            _context2.next = 5;\n            return response.json();\n\n          case 5:\n            request = _context2.sent;\n            console.log(request);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _postToApi.apply(this, arguments);\n}\n\nmodule.exports.callAsync = callAsync;","map":{"version":3,"sources":["/Users/juliankanaan/Documents/GitHub/clientReactInterfact/helpers/helper.js"],"names":["fetch","require","restApiPath","callAsync","url","schema","response","json","data","formatter","returnLines","lines","split","line","push","replace","groupDataReturnArrs","arr","chars","nums","word","isNaN","console","log","getPriceProcedurePairs","jsonData","hospital","procedureName","procedureCost","postToApi","method","body","headers","post","request","module","exports"],"mappings":"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","sourcesContent":["//require('dotenv').config();\nconst fetch = require('isomorphic-fetch');\n// maybe get thus from the ``\nconst restApiPath = 'https://localhost:4000/post/push';\n\n\nasync function callAsync(url, schema) {\n    const response = await fetch(url);\n    const data = await response.json();\n    return formatter(data, schema);\n}\nfunction formatter(data, schema) {\n  // separate into lines\n  /*\n  var lines = returnLines(data);\n\n  for (line of lines) {\n    //\n    getPriceProcedurePairs(line, schema)\n  }\n  */\n  return data;\n\n}\nfunction returnLines(data) { // works: 2:40pm\n  var lines = [];\n  for (line of data.split('\\n')) {\n    lines.push(line.replace(/\\s+/g, ' ')); // trimmed extra spaces\n  }\n  return lines;\n}\nfunction groupDataReturnArrs(line) {\n  // create arr\n  var arr = line.split(\" \");\n  const chars = []; const nums = [];\n  for (word of arr) {\n    //console.log(word);\n    if (!isNaN(word)) {\n      console.log('number');\n    } else {\n      console.log('not num');\n    }\n  }\n}\nfunction getPriceProcedurePairs(line, schema) {\n  // loop concurrently over each array. ALSO: try to catch errors (index out of range, just ignore the bad rows )\n\n  // then join the descriptions together\n\n  // then push into json pairs\n  var jsonData = JSON.stringify({\n    hospital: '',\n    procedureName: '',\n    procedureCost: ''\n  });\n  //console.log(jsonData);\n  return postToApi(jsonData);\n}\nasync function postToApi(data){\n  // push a single data point to DB\n  // NOTE: maybe use bulk insert?\n  const post = await fetch(restApiPath,{\n    method: 'POST',\n    body: JSON.stringify({\n      hospital: data.hospital,\n      procedureName: data.procedureName,\n      procedureCost: data.procedureCost\n    }),\n    headers: {'Content-Type': 'application/json'}\n  });\n  const request = await response.json();\n  console.log(request);\n}\nmodule.exports.callAsync = callAsync;\n"]},"metadata":{},"sourceType":"script"}