{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _parseInt2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/parse-int\"));\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/get-iterator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/esm/asyncToGenerator\"));\n\n//require('dotenv').config();\nvar fetch = require('isomorphic-fetch'); // maybe get thus from the ``\n\n\nvar restApiPath = 'https://localhost:4000/api/post/bulk';\n\nfunction callAsync(_x, _x2, _x3, _x4, _x5) {\n  return _callAsync.apply(this, arguments);\n}\n\nfunction _callAsync() {\n  _callAsync = (0, _asyncToGenerator2.default)(\n  /*#__PURE__*/\n  _regenerator.default.mark(function _callee(url, descStart, descEnd, priceColumn, hospital) {\n    var response, data;\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(url);\n\n          case 2:\n            response = _context.sent;\n            _context.next = 5;\n            return response.text();\n\n          case 5:\n            data = _context.sent;\n            return _context.abrupt(\"return\", transformer(data, descStart, descEnd, priceColumn, hospital));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _callAsync.apply(this, arguments);\n}\n\nfunction givePreview(data) {\n  var preview = [];\n  console.log(data[0]); // pick out three random elements of JSON array\n\n  var rand1 = Math.random() * data.length;\n  var rand2 = Math.random() * data.length;\n  var rand3 = Math.random() * data.length;\n  preview.push(data[rand1], data[rand2], data[rand3]);\n  return preview;\n}\n\nfunction transformer(data, descStart, descEnd, priceColumn, hospital) {\n  var readyVals = []; // separate into lines\n\n  var lines = returnLines(data); // JSON populate\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = (0, _getIterator2.default)(lines), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var line = _step.value;\n      var jsonReady = groupDataReturnRecord(line, descStart, descEnd, priceColumn); //readyVals.push(jsonReady);\n\n      jsonReady['hospital'] = hospital; //console.log(jsonReady);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return readyVals;\n}\n\nfunction returnLines(data) {\n  // works: 2:40pm\n  var lines = [];\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = (0, _getIterator2.default)(data.split('\\n')), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var line = _step2.value;\n      lines.push(line.replace(/\\s+/g, ' ')); // trimmed extra spaces\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  lines.pop(); // there's always an empty element created at end, remove it\n\n  return lines;\n}\n\nfunction groupDataReturnRecord(line, descStart, descEnd, priceColumn) {\n  // create arr\n  var arr = line.split(\" \");\n  arr.pop(); // there's always an empty element created at end, remove it\n\n  var record = {\n    hospital: '',\n    procedureName: '',\n    procedureCost: ''\n  };\n  var cost = arr[arr.length + (0, _parseInt2.default)(priceColumn)]; // probably -2 position\n  // convert relative negative pos for descEnd to positive for this array\n\n  var positiveEnd = arr.indexOf(arr[arr.length + (0, _parseInt2.default)(descEnd)]); // remap\n\n  var description = arr.map(function (word, pos) {\n    if (pos >= (0, _parseInt2.default)(descStart) && pos <= positiveEnd) {\n      return word;\n    }\n  });\n  record['procedureName'] = description.join(\" \").trim();\n  record['procedureCost'] = cost; //console.log(cost);\n\n  return record;\n}\n\nfunction postToApi(_x6) {\n  return _postToApi.apply(this, arguments);\n}\n\nfunction _postToApi() {\n  _postToApi = (0, _asyncToGenerator2.default)(\n  /*#__PURE__*/\n  _regenerator.default.mark(function _callee2(data) {\n    var post, request;\n    return _regenerator.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return fetch(restApiPath, {\n              method: 'POST',\n              body: (0, _stringify.default)({\n                hospital: data.hospital,\n                procedureName: data.procedureName,\n                procedureCost: data.procedureCost\n              }),\n              headers: {\n                'Content-Type': 'application/json'\n              }\n            });\n\n          case 2:\n            post = _context2.sent;\n            _context2.next = 5;\n            return response.json();\n\n          case 5:\n            request = _context2.sent;\n            console.log(request);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _postToApi.apply(this, arguments);\n}\n\nmodule.exports.callAsync = callAsync;","map":{"version":3,"sources":["/Users/juliankanaan/Documents/GitHub/clientReactInterfact/helpers/helper.js"],"names":["fetch","require","restApiPath","callAsync","url","descStart","descEnd","priceColumn","hospital","response","text","data","transformer","givePreview","preview","console","log","rand1","Math","random","length","rand2","rand3","push","readyVals","lines","returnLines","line","jsonReady","groupDataReturnRecord","split","replace","pop","arr","record","procedureName","procedureCost","cost","positiveEnd","indexOf","description","map","word","pos","join","trim","postToApi","method","body","headers","post","json","request","module","exports"],"mappings":"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","sourcesContent":["//require('dotenv').config();\nconst fetch = require('isomorphic-fetch');\n// maybe get thus from the ``\nconst restApiPath = 'https://localhost:4000/api/post/bulk';\n\n\nasync function callAsync(url, descStart, descEnd, priceColumn, hospital) {\n  const response = await fetch(url);\n  const data = await response.text();\n  //const formattedData = transformer(data, descStart, descEnd, priceColumn, hospital);\n  return transformer(data, descStart, descEnd, priceColumn, hospital);\n  //return givePreview(formattedData);\n  // return postToApi(formattedData);\n\n}\n\nfunction givePreview(data) {\n  const preview = [];\n  console.log(data[0]);\n  // pick out three random elements of JSON array\n  var rand1 = Math.random() * data.length;\n  var rand2 = Math.random() * data.length;\n  var rand3 = Math.random() * data.length;\n  preview.push(data[rand1], data[rand2], data[rand3]);\n  return preview;\n\n}\n\nfunction transformer(data, descStart, descEnd, priceColumn, hospital) {\n  var readyVals = [];\n  // separate into lines\n  const lines = returnLines(data);\n  // JSON populate\n  for (var line of lines) {\n    var jsonReady = groupDataReturnRecord(line, descStart, descEnd, priceColumn);\n    //readyVals.push(jsonReady);\n    jsonReady['hospital'] = hospital;\n    //console.log(jsonReady);\n  }\n  return readyVals;\n}\n\nfunction returnLines(data) { // works: 2:40pm\n  var lines = [];\n  for (var line of data.split('\\n')) {\n    lines.push(line.replace(/\\s+/g, ' ')); // trimmed extra spaces\n\n  }\n  lines.pop(); // there's always an empty element created at end, remove it\n  return lines;\n}\n\nfunction groupDataReturnRecord(line, descStart, descEnd, priceColumn) {\n  // create arr\n  var arr = line.split(\" \");\n  arr.pop(); // there's always an empty element created at end, remove it\n\n  const record = {\n    hospital: '',\n    procedureName: '',\n    procedureCost: ''\n  }\n\n  const cost = arr[arr.length + parseInt(priceColumn)]; // probably -2 position\n  // convert relative negative pos for descEnd to positive for this array\n  const positiveEnd = arr.indexOf(arr[arr.length + parseInt(descEnd)]);\n  // remap\n  var description = arr.map((word, pos) => {\n    if (pos >= parseInt(descStart) && pos <= positiveEnd) {\n      return word;\n    }\n  });\n\n  record['procedureName'] = description.join(\" \").trim();\n  record['procedureCost'] = cost;\n  //console.log(cost);\n  return record;\n}\nasync function postToApi(data) {\n  // push a single data point to DB\n  // NOTE: maybe use bulk insert?\n  const post = await fetch(restApiPath, {\n    method: 'POST',\n    body: JSON.stringify({\n      hospital: data.hospital,\n      procedureName: data.procedureName,\n      procedureCost: data.procedureCost\n    }),\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  const request = await response.json();\n  console.log(request);\n}\nmodule.exports.callAsync = callAsync;\n"]},"metadata":{},"sourceType":"script"}